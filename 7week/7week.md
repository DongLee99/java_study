## 자바 기초

### 학습할 것 (필수)

- 자바 상속의 특징
- super 키워드
- 메소드 오버라이딩
- 다이나믹 메소드 디스패치 (Dynamic Method Dispatch)
    - 더블 디스패치
- 추상 클래스
- final 클래스
- Object 클래스

---

### 자바 상속의 특징

- 상속이란? 현실 세계에서 쓰이는 상속이란 말에 대해 생각해 보자 부모의 자산등을 자식에게 물려주는 의미로 많이 쓰는 단어 이다. 그렇다면 이 상속이 자바에서는 어떤 식으로 쓰이는지 한번 알아보도록 하자.

 **자바에서의 상속** 

- 객체 지향 프로그램에서 상속은 비슷한 의미로 작용한다. 현실 세계 처럼 부모가 자식에게 물려주는 의미로  부모 클래스의 멤버나 메소드를 자식의 클래스에게 물려줄수있다.
- 상속을 사용함으로 공통된 특징을 가지는 클래스에서  코드 중복을 줄여주고 부모 클래스의 멤버를 재사용 하면서 자식클래스의 간결함을 유지 시켜준다.
- 클래스간의 계층적 분리를 도와줘 분류, 관리의 이점이 있다.

**상속의 특징**

- 부모 클래스 → Super class

       자식 클래스 → Sub class

- 자바는 다중 상속을 지원 하지 X → extends 뒤에는 하나의 부모 클래스만 올수 있다.
- 상속 횟수에 제한 X
- 자바의 최상위 클래스는 Object 이다. 즉 자바의 모든 클래스는 Object 의 자손

**상속 방법**

1. 상속 방법

```java
class 자식클래스 extends 부모클래스{

}
```

2. 부모 클래스

```java
public class Tv {

	String
```

3. 자식 클래스

```java
public class Samsung extends Tv {
		
	String tvType;
}
```

---

## super 키워드

- 자바에서 자식 객체를 생성하면 부모객체의 메소드나 필드 값을 사용이 가능하다 그렇다면 자식 객체 생성시 부모객체는 생성이 되는게 아닌가? 그렇지 않다 자식 객체 생성시 부모 객체가 먼저 생성되고 이후에 자식 객체가 생성된다.

**super 키워드란?**

- super 키워드는 상속관계에서 부모 클래스의 필드나 메소드를 참조하기 위해서 사용된다. ( 부모 클래스의 메소드나 필드를 자식 클래스에서 재정의 했을경우에 부모클래스를 사용하기위해 사용한다 )
- 객체가 생성되기 위해서는 생성자가 필요하다 그렇다면 자식 객체 생성시 부모 객체는 어떻게 생성이 될까?

→ 이는 개발자가 따로 부모 객체의 생성자를 자식 클래스에 지정해 놓지 않았다면 컴파일러가

```java
super() 
```

를 통해 부모의 기본 생성자를 호출한다.

- 자식 클래스에서 부모 객체의 생성자를 호출하고 싶을 시에도 같은 방법으로 작성하면 된다.

---

## 메소드 오버라이딩

- 오버 라이딩은 상속관계에서 매우 중요하다 현실 세계에서 부모에게 자산을 물려 받았다고 생각을 하면 그 자산을 자신이 원하는 방식으로 사용을 한다. 이 원하는 방식으로 사용을 도와주는게 오버라이딩이다.

**오버라이딩**

- 상속은 extends 키워드를 통해 부모 클래스의 메소드나 필드를 물려 받게된다. 이때 물려 받았으면 그 자체를 같은 방식으로 사용 할 수 있지만 보통 재정의해 사용하는 경우가 많다. 이때 부모 클래스로 부터 상속 받은 메소드를 재정의 하는걸 오버라이딩이라 한다. 이렇게 재정의를 할 경우 부모의 메소드는 은닉되고 자식의 메소드가 호출된다.

```java
 public class Tv {
	
		 public void getInfo() {
					 System.out.print("티비 입니다.");
		}
}
```

```java
public class Samsung extends Tv {

	@Override
	public void getInfo() {
		System.out.print(" 삼성 티비 ");
	}
}
```

**규칙**

1. 부모의 메소드와 동일한 형태여야한다( 리턴타입, 이름, 매개변수)
2. 접근 제한자를 더 강하게 둘수 없다.
3. 새로운 예외 금지

---

## 다이나믹 메소드 디스패치

- 메소드 디스패치? 어떤 메소드를 호출할지 결정하는 과정

**Dynamic Dispatch**

- 런타임 시점에서는 어떤 메소드를 호출해야할지 모르고 추상 타입의 메소드를 호출하는 것만 알고 있는데 할당된 객체의 타입을 보고 메소드를 결정하는 것을 의미한다.

    예를 보고 이해를 해보자

```java
public class Tv {
	public void view() {
		System.out.println("티비를 보여줌");
	}
}

public class Samsung extends Tv {
	
	@Override
	public void view() {
		System.out.println("OLED 티비를 보여줌");
	}
}

public class Main {
	public static void main(String[] args) {
		Tv tv = new Tv(); // Tv 참조 Tv 객체
		Tv samsungTv = new Samsung(); // Tv 참조, 삼성 객체
	
		tv.view(); //참조와 객체가 동일
		samsungTv.view();// 참조와 객체가 다름 (상속) => 다이나믹 메소드 디스패치
	}
}
```

- 컴파일 시에는 참조 타입만 확인하지만 런타임시 JVM 이 객체 타입을 파악해 메소드를 실행시켜준다.

**Double Dispatch**

- Dispatch 가 연속적으로 이뤄지는것을 의미한다.

---

## REFERNCE

[https://scshim.tistory.com/210](https://scshim.tistory.com/210)

[https://velog.io/@dion/백기선님-온라인-스터디-6주차-상속](https://velog.io/@dion/%EB%B0%B1%EA%B8%B0%EC%84%A0%EB%8B%98-%EC%98%A8%EB%9D%BC%EC%9D%B8-%EC%8A%A4%ED%84%B0%EB%94%94-6%EC%A3%BC%EC%B0%A8-%EC%83%81%EC%86%8D)