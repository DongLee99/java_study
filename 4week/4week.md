# 4주차 과제 : 자바 코드 작성해보기

## 1. 자바 코드 실습
---
* 정리할 것
    1. 역할, 책임, 협력(객체지향의 사실과 오해) → 제일 중요한것은 메세지다
    2. vo(불변객체)
   
---
목차
* [자바 코드의 실습](#자바-코드의-실습)
	
    * 역할, 책임, 협력
    	
        * [객체 지향의 사실과 오해](#객체-지향의-사실과-오해)
        	
            * [객체 지향의 Goal](#객체-지향의-Goal)
            * [객체 지향이란?](#객체-지향이란?)
            * [객체 지향의 중요한 3가지 개념](#객체-지향의-중요한-3가지-개념)
            * [협력](#협력)
            * [책임](#책임)
            * [역할](#역할)
            * [메시지](#메시지)
            * [캡슐화](#캡슐화)

 
### 객체 지향의 사실과 오해

> 객체 지향의 사실과 오해에 대해 알아보려면 우선 객체 지향이 뭔지에 대해서 알아야 한다. 우리는 지금 자바 스터디를 하고있다. 자바가 객체 지향 언어라는 것은 알고있지만 객체 지향에대해 따로 생각해본적은 없었다. 그렇다면 객체 지향이란?

---

#### 객치 지향의 Goal
* 객체지향의 목표는 실제 세계를 모방하는것이 아니다. 새로운 세계를 창조하는 것이다.
	
    * 이 말에 예를 들자면 실제 세계의 커피라는 객체를 생각 해보자 ![](https://images.velog.io/images/donglee99/post/92b4d646-afde-43ab-a6a2-00210380ef54/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-01-20%20%EC%98%A4%ED%9B%84%2012.25.30.png) 
    * 이커피는 실제 세계의 커피 이다. 그렇다면 객체 지향에서 커피는 객체가 될수있다. 현실세계와 객체지향언어에서의 커피의 차이점은 **현실 세계의 커피는 스스로 온도를 조절 할 수 없고 양도 조절할 수 없다.** 하지만 **객체 지향에서의 커피는 스스로 온도 조절이 가능하고 양 조절도 가능하다.** 이처럼 객체 지향은 실제를 모방하는 것이 아니라 새로운 세계를 창조한다는 말이 성립이 된다.
	
    
_ 그래서 객체 지향은?_
자바를 생각하면서 객체 지향을 떠올리면 가장 먼저 떠오르는것은 클래스 이다. 비록 다른 사람의 글을 보면서 글을 적고 있지만 이 사람 처럼 수업 시간에 배웠던것 처럼 자바 => 클래스 가 공감이 된다. 우리 학교도 수업시간에 자바를 하면 클래스만 주구장창 배웠기 떄문이다.

코딩의 관점에서 본다면 클래스가 객체를 만들기위한 틀, 도구이기에 객체지향을 클래스 라고 착각할수가 있다. 객체지향의 주인공은 클래스가 아니라 객체 이다. 이 객체를 분류 하기 위한 것이 클래스 이다. 따라서 코드를 담는 클래스의 관점이 아닌 메시지를 주고 받는 객체의 관점으로 애플리케이션을 바라 보아야 한다.

---

#### 객체 지향 이란? 
* 객체 지향은 시스텀을 상호작용하는 자율적인 객체들을 공동체로 바라보고 이 객체를 이용해 시스템을 분할 하는 방법이다.
* 자율적인 객체란 스스로 자기자신의 상태와 행위를 조절 할 수있는 객체이다.
* 객체는 시스템을 구현하기위해 다른 객체와 메세지(유일한 의사소통 수단)로 협력을 한다. 각 객체는 협력 내에서 정해진 역할을 수행하며 이 역할에 대한 책임을 가지게 된다.
* 메시지를 수신한 객체는 메시지를 처리하기 위해 적합한 메서드를 스스로 선택을 한다.
* 객체는 상태와 행동을 함께 지닌 실체라고 정의를 하며 이말은 객체가 협력에 참여하기위해서는 어떤 행동을 해야한다면 그 행동을 하기위해 필요한 상태도 지녀야 한다. (객체는 상태와 행위를 함께 지니고 있음)

#### 객체 지향의 중요한 3가지 개념 
	
    1. 협력 
	2. 역할
	3. 책임
    
* 카페를 가는 것으로 위 3가지를 다뤄 보면
	
    * 카페에서 주문을 한다 = 나 ( 요청 ) 판매자 ( 응답 ) = 협력
    * 나, 판매자의 위치 = 역할
    * 나 = 구매를 한다. ,판매자 = 손님의 요청을 받고 응답을 하는 행위를 한다 = 책임
* 객체의 세계에서는 협력이라는 문맥이 객체의 행동 방식을 결정하게 된다.
* 객체지향 개발에서 가장 중요한 능력은 책임을 능숙하게 소프트웨어 객체에 할당하는것이다.

---

#### 협력 

* 특정한 책임을 수행하는 역할들 간의 연쇄적인 요청과 응답을 통해 목표를 달성한다.
(사용자가 최종적으로 인식하게 되는 시스템의 기능 = 객체들의 협력의 결과)
* 혼자만의 힘으로 해결하기 힘든 문제를 여러 사람이 함께 해결한다. 이과정에서 요청 -> 응답의 연쇄적인 흐름이 발생하게 된다. 이 요청과 응답은 협력하는 객체의 책임을 정의 하게 된다.

---

#### 책임 
* 애플리케이션의 기능은 좀 더 작은 책임으로 분할되며 책임은 적절한 역할을 수행할수 있는 객체에 의해 수행된다. ( 객체 지향 설계 = > 적절한 객체에 적절한 책임을 할당함으로 부터 시작)
* 책임의 분류
	
    * 하는 것 (doing)
    	
        * 객체를 생성, 계산등의 스스로 하는 것
        * 다른 객체의 행동 시작 시키는 것
        * 다른 객체의 활동을 제어하고 조절 하는것
    * 아는 것 (knowing)
    	
        * 개인적인 정보에 대해 아는 것
        * 관련된 객체에 대해 아는 것
        * 자신이 유도하거나 계산할 수 있는 것에 대해 아는 것
        
(그냥 내 생각인데 이는 자바에서 코드를 짤때 메서드를 호출해 직접 상태를 변형 시키거나 다른 객체의 상태를 변형 시키는 것, 이때 변환 시킬 객체를 아는 것 등을 의미하는것 같다)
* 책임과 메시지
	
    * 위의 doing, knowing을 보면 자신의 상태를 변환 시키는것들도 있지만 다른 객체에 관여 하는것도 많다 이때 객체의 유일한 의사소통 수단인 메시지가 사용된다는 사실을 유추해 낼수 있다.
    * 너무 추상적인 메시지는 의도가 변형될수있으므로 구체적이여한다.

---

#### 역할 
* 역할은 관련성이 높은 책임의 집합으로
	
    * 동시에 여려객체가 동일 역할을 수행 할수있다.
    * 역할은 대체 가능성을 의미한다.
    * 각 객체는 책임 수행 방법을 자율적으로 선택 가능하다.
    
---
#### 메시지 
* What/Who 사이클
	
    * 책임-주도 설계의 핵심은 어떤 행위가 필요한지 검토후 이를 수행할 객체를 결정하는 것이다.
    이과정을 What/Who 사이클이라 한다.
   * What/Who 사이클의 의미는 객체 사이의 협력 관계를 설계하기위해 어떤 행위 What를 수행할것이고 누가 수행Who 할것인가를 결정하는 것인데 이때 어떤 행위 = 메시지 이다.
   * 객체가 어떤 메시지를 수신하고 처리할 수 있는냐에 따라 객체의 책임이 결정된다.
* 묻지 말고 시켜라
	
    * 메시지 송신자는 수신자에대한 정보를 모르기 때문에 캐물을 수 없다. 단지 자신이 전송한 메시지를 잘 처리할 것이라고 믿고 전송한다.
    * 객체는 다른 객체의 상태를 묻지 말아야 한다. 객체가 다른 객체의 상태를 묻는 다는 것은 메시지 전송 이전에 객체가 가져야 하는 상태에 관해 너무 많이 고민 하고 있다는 증거이다.
* 메시지를 믿어라
	
    * 메시지는 전송 시점에 자신이 전송한 메시지를 수신할수 있다면 협력하는 객체의 종류가 무엇인지는 중요하지 않게 된다. (커피를 주문 하는 시점에 누가 주문을 받던지 상관이 없다 나는 커피만 받으면 된다)
    * 중요한것은 수신한 객체가 메시지를 정확하게 이해하고 메시지를 전송한 객체가 의도한대로 요청을 처리할 수 있는지 여부다. (커피를 받는 그 자체)
    * 메시지를 이해할 수 있다면 다양한 타입의 객체로 협력 대상을 자유롭게 교체 가능 -> 설계의 유연 (다형성)
---
#### 캡슐화 
* 객체의 자율성을 보전하기 위해 구현을 외부로 부터 감추는 것
* 객체는 상태와 행위가 함께 캡슐화 되어 충분히 협력적이고 자율적인 존재가 된다.
	
    * 상태와 행위의 캡슐화
    	
        * 객체는 상태와 행위의 조합으로 객체자체가 상태와 행위를 하나의 단위로 묶는 자율적인 실체가 된다 이를 데이터 캡슐화 라고 칭한다.
    * 사적인 캡슐화
    	
        * 객체는 외부의 객체가 자신의 내부를 제어, 관찰이 불가능하게 막는다.

---
#### Reference
* [객체지향의 사실과 오해](https://jongmin92.github.io/2019/02/10/Programming/object_oriented_facts_and_misunderstandings/)
* [객체지향의 사실과 오해 정리](https://jheloper.github.io/2020/02/object-oriented-facts-and-misunderstandings-01/)
* [TIL/객체지향의 사실과 오해](https://github.com/cheese10yun/TIL/blob/master/OOP/객체지향의사실과오해.md#협력)
---
### VO(불변 객체)

> Immutable Object란? 객체 지향 프로그래밍에서 불변 객체는 생성후 그 상태를 바꿀수 없는 객체를 의미한다. 당연히 반대인 가변 객체도 있다. 가변 객체로 생성후 불변객체로의 변환도 가능하다. 객체의 전체가 불변인 경우도 있고, C++에서 Const 데이터 멤버 처럼 일부 속성만 불변인 경우도 있다. 또 경우에 따라서는 내부 속성이 변화 해도 외부에서 그 객체의 상태가 변하기 않는다고 보이면 불변 객체로 보기도 한다. 불변 객체를 사용시 복제나 비교를 위한 조작을 단순화 할수 있으며, 성능 개선에 도움을 준다. 하지만 객체가 변경이 가능한 데이터를 많이 가지고 있다면 오히려 부적적할 경우가 있다.

#### 자바에서의 Immutable Class 
* 자바에서의 Immutable Class 는 String, Boolean, Integer, Float, Long 등등이 있다. 이 클래스들은 Heap 영역에서 변경이 불가능 한거지 재할당을 못하는 것은 아니다.
``` java
String str = "abc";
str = "cba";
```
위 코드 처럼 재할당이 가능하다. = str 이 처음에 "abc" 를 참조했는데 이 값이 "cba" 로 바뀌는 것이아니라 "cba"라는 새로운 객체가 생기고 그 객체를 str 이 재참조 하는것이다. 이때 "abc" 는 아무도 참조를 하고있지 않게 된다.

_그렇다면 계속 str에 재할당을 한다면 객체가 생성된채로 낭비가 된다는 것인데 이는 어떻게 처리하는게 옳은 방법일까?_

* String vs String Builder
	
    * String Builder 는 String 과 다르게 mutable 하기 때문에 변경을 하더라고 새로운 객체를 만들지 않고 기존 할당된 값을 수정 한다. 즉 문자열 변경과 연산을 하는 경우 기존의 버퍼 크기를 늘리거나 줄이면서 유연한 동작이 가능하게 된다.


* 불변 클래스의 예
``` java
class ImmutableClass {
	private final int age;
    private final String name;
    
    public ImmutableClass(int age, String name) {
    	this.age = age;
        this.name = name;
    }
}

```
위의 코드는 외부에서 수정이 불가능한 불변 객체가 된다.
불변 객체가 된 가장 큰이유는 멤버 변수를 private final로 선언하고 setter를 구현하지 않았기 때문이다.


``` java
class MutableClass {
	public  int age;
    public  String name;
    
    public MutableClass(int age, String name) {
    	this.age = age;
        this.name = name;
    }
}

```
위 코드는 외부에서 수정이 가능하므로 불변 객체가 X

#### Immutable Object 만들기

* Immutable Object 를 만들때 기본적으로는 필드에 final을 사용하고 Setter를 구현 하지않는다.
이는 불변객체의 필드가 모두 원시 타입일 경우에만 가능하고, 참조 타입일 경우엔 추가적인 작업이 필요하다.

** 원시타입만 있는 경우 **
``` java
public class BaseObject {
    private int value;
    
    public BaseObject(final int value) {
    	this.value = value;
    }
    
    public void setValue(int new Value) {
    	this.value = newValue;
    }
}

```
* 위의 객체는 불변 객체가 아니다 setter 도 존재하고 필드도 final로 선언되어있지 않다.
필드에 원시 타입만 있으므로 이는 final 키워드로 불변 객체로 만들수 있다.

``` java
public class BaseObject {
    private final int value;
    
    public BaseObject(final int value) {
    	this.value = value;
    }

}

```

* 위의 코드는 final과 setter 의 삭제로 불변 객체로 만들어 주었다. 따라서 위 객체의 value 를 변경하기 위해서는 재할당 하는 방법 밖에 없다.
** 참조 타입이 있는 경우 **
* 참조 타입이 있는 경우는 final을 사용하고 setter를 작성하지 않는 것으로 불변 객체를 만들수 없다.

``` java
public class Animal {
    private final Age age;
    
    public Animal(final Age age) {
    	this.age = age;
    }
    
    public Age getAge() {
    	return age;
    }
}
class Age {
    
    private int value;

    public Age(final int value) {
        this.value = value;
    }

    public void setValue(final int value) {
        this.value = value;
    }
    
    public int getValue() {
    	return value;
    }
}

```
* 위 Animal 클래스는 final 을 사용하고 Setter 를 구현하지 않았지만 불변 객체가 아니다 그이유는 클래스 필드인 Age 값이 변경이 가능하기 때문이다. 따라서 Animal 클래스가 불변 객체가 될려면 Age 클래스도 불변 객체가 되어야 한다. 즉 참조 변수도 불변 객체 여야 한다.
** Array 경우 **
```java
public class ArrayObject {

    private final int[] array;

    public ArrayObject(final int[] array) {
        this.array = Arrays.copyOf(array,array.length);
    }


    public int[] getArray() {
        return (array == null) ? null : array.clone();
    }
}
```
* 배열의 경우 생성자에서 배열을 받아 copy해서 저장 했고 getter를 clone 으로 반환하게 하면 불변객체로 만들수있다. (배열을 그대로 참조 or 그대로 반환시 내부 값이 변경될수도있다.)
---
#### Reference
* [java Immutable Object(불변객체)](https://velog.io/@conatuseus/Java-Immutable-Object불변객체)
---

